# -----------------------------------------------------------------------------
# Phase 1: RSA Key Generation
# -----------------------------------------------------------------------------

from sympy import nextprime, gcd, mod_inverse, Integer
import random
 
# Function to generate a 300-digit prime number with a given seed
def generate_large_prime(digits, seed):
    random.seed(int(seed))  # Convert seed to a standard int
    start = random.randint(10**(digits - 1), 10**digits - 1)  # Generate a random 300-digit number
    prime = nextprime(start)
    # Ensure prime has exactly the number of digits requested
    while len(str(prime)) != digits:
        start = random.randint(10**(digits - 1), 10**digits - 1)
        prime = nextprime(start)
    return prime
 
# Function to generate a random 'e' which is coprime with φ(m)
def generate_random_e(phim, seed):
    random.seed(int(seed))  # Convert seed to a standard int
    while True:
        e = random.randint(2, phim - 1)  # Random e, less than φ(m)
        if gcd(e, phim) == 1:  # Ensure gcd(e, φ(m)) = 1
            return e
 
# Define the number of digits for p and q
digits = 300
 
# Use seeds for reproducibility
seed_p = 42
seed_q = 43
seed_e = 44
 
# Generate 300-digit prime numbers for p and q
p = generate_large_prime(digits, seed_p)
q = generate_large_prime(digits, seed_q)
 
# Ensure p and q are distinct for security
while p == q:
    q = generate_large_prime(digits, seed_q + 1)  # Change seed to generate a different q if p == q
 
# Print the prime numbers p and q
print("Prime number p:", p)
print("Prime number q:", q)
print("Number of digits in p:", len(str(p)))
print("Number of digits in q:", len(str(q)))
 
# Calculate RSA modulus m
m = p * q
print("RSA Modulus (m):", m)
 
# Calculate Euler's Totient function φ(m)
phim = (p - 1) * (q - 1)
print("Phi of m (φ(m)):", phim)
 
# Generate a public exponent 'e' that is coprime with φ(m)
e = generate_random_e(phim, seed_e)
print("Public Key (e):", e)
 
# Compute the private key 'd', where d is the modular inverse of e modulo φ(m)
d = mod_inverse(e, phim)
print("Private Key (d):", d)
 
# Validate the key correctness
# Check if e * d mod φ(m) = 1
assert (e * d) % phim == 1, "The keys do not satisfy the RSA condition e * d ≡ 1 (mod φ(m))"
print("Key verification successful: e * d ≡ 1 (mod φ(m))") 
 
# -----------------------------------------------------------------------------
# Phase 2A - Encryption Phase
# -----------------------------------------------------------------------------
 
# Convert text to an integer using ASCII values with padding if needed
def text_to_int_ascii(message):
    ascii_values = ''.join(f"{ord(char):03}" for char in message)
    return Integer(ascii_values)
 
# Encrypt a message segment using RSA
def encrypt_message(segment, e, n):
    segment_int = text_to_int_ascii(segment)
    if segment_int >= n:
        raise ValueError("Segment is too large for encryption with the given RSA modulus n.")
    return pow(segment_int, e, n)
 
# Split the message into segments with a given word count
def split_message_into_segments(message, num_segments=10, words_per_segment=10):
    words = message.split()
    return [' '.join(words[i:i + words_per_segment]) for i in range(0, len(words), words_per_segment)][:num_segments]
 
# RSA parameters
message = (
    "Amid the gentle hum of the city, beneath a vast sky turning shades of purple and orange as dusk settled in, Clara walked along the winding riverside path, admiring the swaying trees whose leaves glistened in the fading light, while distant sounds of laughter and music from a nearby café floated through the air, mingling with the soft rustle of the wind, she breathed in the fresh scent of earth and foliage, feeling the day worries slowly drift away, as if carried off by the gentle current of the river, which sparkled under the warm glow of the setting sun."
)
e = 65537
n = 258264548125699952880278502905874102080356125792942932256640127629902236373181669002150021235011378006943151639413105864797817559998299347266642806064228476283756900246325696597206677993455571505722117396503656374189182491934030243325828438813950275798333140626482547794320674986132310598245738095353408793968252502920107975018149651526222524152077706704823926926604976837727263955602415832041424169450145863250289847654535228483628571867656661114896676176780222149351440694284671718936087461242404379069567899846285902361232676356512517085342820769627470493216422856043101698215187955720768773117857
 
# Split message and encrypt each segment
segments = split_message_into_segments(message)
encrypted_segments = [encrypt_message(segment, e, n) for segment in segments]
 
# Output encrypted segments
for i, encrypted_segment in enumerate(encrypted_segments, 1):
    print(f"Encrypted Segment {i}: {encrypted_segment}")

# -----------------------------------------------------------------------------
# Phase 3 - RSA Decryption Phase
# -----------------------------------------------------------------------------
 
# Define your private key components
d = 3658895641423221385109691371222498566133518171219566597578312931388787787332485593422381298854404188111189243145736450055218435349675419896188335991412381658128630538906373336343273760731242521591989462300361823095588200857251439197424623087652541133106542200353081440328416497852410400671260550895676196554849595977755792979038489608056907396510812064622158839906164925211416800073050993557893742178078112233439097699547899467020676643414438387903484342928798878818567395409341115049715337649761852942592612432130230873801172393118851056863210485037994326357425395087677380215992554661551751521805
m = 99526824909357608735373738297348916425863684905485421151271720491644532142465651442155734405021184316995747721550817497229047477236933172454742484643089640237082234030021934333296240866409052458462374605606104491514987275255927496078718407079599737236331437055680113614367364127877940589950840857083702913870308940798213041836695854401753791020624799807504686718323215230509387243840322040482324946716982423132106770723347700149342670412773080049049016504036344000522273098804412996870069285097879802684004674963451378503764310748180392758472515954893933445902386958071092025203979323791124075349851
 
# Encrypted segments from your text file
encrypted_segments = [
    # Add your encrypted segment values here as integers, e.g.,
    14596100677726967772804915226568645970898063295106491588196750865408620502234922591307269161062967846770004219142222153030906584386438262075071949304212182943647314517057346611134921834643269436839803113117695904138907703937528902172565727239530278621521212548030446745366922659905555291046358650563731565599759213101502900369210511516242748223565244202292501630867261317200751722835804514086361541894361214819014289232840744483260882796114663858209190744886031783358329573927588064916746416836125676687987032699990497886514930615988266144732974307919508388630651502210971028935208227290800530379474,
    91075942299872558696710715429997419673209384910456404225350133319922991992851163102970410960042035271015715935540787933977934684863609071724280140032521388429989264703829135093155590375913699546889114724682790147828815991999592163015100583562225780467413590332694921186714560750465377593054549383303082899570179320927221088001061682283290637222978295070166516164873631615533753111061157056707509789698136621848288657398221674078101828440918740916637377800415818485383014352460676726485725270160700172933255260025703549292245539563252814995471541489275345976523659043337450901706272395377141820224682,
    65457972218044039239454777913205951993651075571748488625070669737997675426391581385669059358904441192023038984724959236682613481047879019222886145971021116413028060821717325399236550444388595100656958386890118169816148500871383666723429288028612266225763129125001835321011161400657218564999852980638936617187324177898152805589934694839942010784220968646575093602443244476329171713123382096555501820528387071108075098242693539233784754314163305412421038233591381159500509110065295346909102926774455053136005828267838364303325127466544190350974987427910010541943717432178315266899020902132402678822136,
    64181761449790614944902372324435496649184167875952820451065849024896471088705612525672505511029954045242171051865508867544563115982018210454070131330765191905062996748551683991812614064563213882713755511572915905696782009815963819747535456562634425585820039694117203720117021729882935400450214780990734310083606846103848954532805862518970560818281073176737171657985548870151389296458402887743326263737748475298541353284752310381994116446676158536039719964125886602326004378255474596530217328163505918962425682374821462802567782577875159578451784301207885020846924333192952061128326144586788074518451,
    21168563868466590304811688952901666984501018109728197848664671900284835393778087000431527252263051473722444840478068676469422258481646594240786488301972236234277371662496845448577956660598355432216604398864882477430931348216470990617556017331198239040624347511888619571975687534011975907859237181314596788869111175919783262141243278982775435767266024448727742528466444489311671169332136594736467724390493617406570838229121216405606330145695726698615521396245018051911853834192575676800555466542152852606657695579610006017181890234545887446181032303004870627215186773934450002197895935812096918428592,
    15672498599844944565851350603395369624446571888305825978746663082981182573686356278660960593329313901554293371542479997662284986031126917813066451660822774062140387320539009633228839130915500722615001560052854592849186200366718244734022369440141476984776650053022795196322847027714900443202716521797021515371940708350140037046038438169492449868281688244611109351072942663530893687752959572486688790134356153094758284717963722998646200816458673975298358353279478754494748595870140600677172224612441721976558949389484141479837794295678375984614991610266486727447067389955004053493498284904832119381540,
    57040172758093480264635398043943697795664135620689832861707426656522953238187391644136277198956170476680290701787168437768111703572112366933769473675276617929124293698466729908816778792526528641353711834118605184276980514764134328650995762941857630380638184044016668010835297328265095985600114906603995588639716097282888874200184581222099051359115915269064496045383436060834417079573020840179709724414880982152571308366850491892933440406609018243078527155450688273074656046245100943746586819179264981005297477378622614472472945642940863919891113011453283189936927662576090253548560600472402467186658,
    27497202112303889681361778131623179705382547852907096613997189084972810900385155682943323824182088163862357229933727579488140434858830848055341865085828824830834740661167681524236361212597844426316799672515901765829207876161746594047917425371978030600315541769725492976471983870706188799247220584601096931173791440970497492811595243050948485343784120609970715346081346995489429428012281067896186221843133198611582905781269106221898386101780240814065360856297576028691351513861682815652595353917991026886762101358137901589685427789726739101465740571297837189764177179062858601626919419253773358874554,
    16192621851515461530072605506649756874020108147428604659104749405874161586892804841425311012161908044629978353404768543555391274093391888548289606974339790414881545959977269373560252177409618014899484917605090890392445176038961676514342808237608732962597712591596089496137830798833245390736452170664672542200750883654645582742152286007135963739816513299209452547608371420706981180516939598083862302569981144012785258248603967853832483055536532997236152354047251458215753364621843852822959548517145169922663661833909659913655841772630114600076417357242799162689271310372292490801093681879141275406477,
    50697346628199264873997697622327365564160312957571967655537051131480378663188255675793413061431863162416523042143876616012971205647644231956771888665763293076396457883910834081340345935326672106100525930653370885718356538232621205759294521494629780353883577844451007482876994715133585335284681167077886237206732876018939854182437494301447150740954164751385186563866698144657830246470494976810399362871160803352606805995011545735320961461342363013979179888911587107186445302148624127948295373420662976384101387480967139028441802392071497185755625833274804547604693613684280530696451717977292011660546
    # Continue adding all other segments...
]
 
# Function to decrypt each segment
def rsa_decrypt(ciphertext, d, m):
    return pow(ciphertext, d, m)
 
# Decrypt each segment
decrypted_segments = [rsa_decrypt(segment, d, m) for segment in encrypted_segments]
 
# Convert decrypted integer back to ASCII characters
def int_to_ascii(decoded_int):
    decoded_text = ""
    # Split the integer into groups of three (each representing an ASCII character)
    while decoded_int > 0:
        ascii_code = decoded_int % 1000  # Extract the last three digits
        decoded_text = chr(ascii_code) + decoded_text
        decoded_int //= 1000
    return decoded_text
 
# Convert each decrypted segment back to text
decoded_text_segments = [int_to_ascii(segment) for segment in decrypted_segments]
 
# Print the decoded text segments
for i, text in enumerate(decoded_text_segments, 1):
    print(f"Decoded Segment {i}: {text}")
 